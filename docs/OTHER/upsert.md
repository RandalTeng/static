数据库统计记录相关技巧
==

MySQL语法篇
--

``` sql
replace into tbl(col1, ...) values(val1, ...)
/**
 * 类似 insert into, replace先尝试插入表
 * 如果表中已有记录(主键/唯一索引), 删除原有记录重新插入
 * 否则直接插入新数据, 未指定的字段使用默认值, 未指定默认值使用null
 */

replace into tbl(col1, ...) select ... from ... where ...
/**
 * 类似 insert select, replace从子句里面查询出所有结果, 直接导入tbl, 全量覆盖
 * 空字段使用默认值填充
 */

replace into tbl set col1 = val1, ...
/**
 * 类似 update set, replace指定字段更新为新值
 */

-- replace into 在没有主键或唯一索引的使用场景下与insert into 行为完全一致
-- 数据库没有标准判断新插入的行是否与其他行重复
```

缓存标识篇
--

一般做数据统计的时候流程为:

``` text
根据条件查询记录是否已被插入(第一次SQL)
    a. 如果数据已被插入: 累增原有记录, 保存(第二次SQL)
    b. 如果记录为空:
        1) 插入新默认行, 保存(第二次SQL); 累增新行, 保存(第三次SQL)
        2) 直接把需要更新的字段设置为新值, 插入保存(第二次SQL)
```

> 就是说, 这样子更新, 最少有2次SQL, 最多3次

使用缓存标记数据已插入状态:

``` text
根据条件查询记录是否已被插入, 查询缓存标记
    a. 如果数据已被插入: 累增原有记录, 保存(第一次SQL)
    b. 如果记录为空:
        1) 插入新默认行, 保存(第一次SQL, 更新缓存标记); 累增新行, 保存(第二次SQL)
        2) 直接把需要更新的字段设置为新值, 插入保存(第一次SQL, 更新缓存标记)
```

使用缓存做数据统计, 定时同步到数据库
--

``` text
做一个统计HASH key, 每次统计更新缓存
做一个定时任务, 读取HASH, 同步到数据库(单位时间内, 一次SQL)
```

PS: 这里使用Redis的hincrby做处理, 简单方便, 每次直接执行 `hincrby key field value`
但是会有一个缺点, 后台统计表格里面, 不会有当前单位时间内的统计数据
也可以在后台查询的时候直接查询缓存当前单位时间的数据, 累计到数据记录里面
适合高并发情况, 后台不需要实时统计数据, 允许一定时间的延迟

消息队列同理, 定时消费消息
