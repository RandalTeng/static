Daily Class Record
==

About \stdClass
--

``` php
- \stdClass
/**
 * 基础类对象可以随意添加任何属性
 */
$obj = new \stdClass();
$obj->a = 1;
$obj->b = 2;
var_dump($obj);
/**
 * output:
 * object(stdClass)[1]
 *   public 'a' => int 1
 *   public 'b' => int 2
 */
```

关于 `面向对象` `面向过程` `面向切片(切面)` 这些网上文章一大堆, 这里不做详细介绍

面向对象设计
--

抽象各种对象, 对象有对应的数据和方法(能力)

`封装` `继承` `多态`

> OCP 开闭原则  
> SRP 单一职责原则  
> LSP 里式替换原则  
> ISP 接口分离原则  
> DIP 依赖导致原则/控制反转(IoC)
> REP 复用、发布等同原则
> CCP 共同闭包原则
> CRP 共同复用原则

``` text
OCP:  
    设计良好的软件应该易于扩展, 同时抗拒修改  
    这是我们进行架构设计的主导原则, 其他的原则都为这条原则服务  
SRP:  
    任何一个软件模块都应该有且只有一个被修改的原因, “被修改的原因“指系统的用户或所有者  
    翻译一下就是, 任何模块只对一个用户的价值负责  
    该原则指导我们如何拆分组件  
LSP:  
    当用同一接口的不同实现互相替换时, 系统的行为应该保持不变  
    该原则指导的是接口与其实现方式  
ISP:  
    不依赖任何不需要的方法、类或组件  
    该原则指导我们的接口设计  
DIP:  
    跨越组建边界的依赖方向永远与控制流的方向相反  
    该原则指导我们设计组件间依赖的方向  
REP:  
    软件复用的最小粒度应等同于其发布的最小粒度。直白地说, 就是要复用一段代码就把它抽成组件  
    该原则指导我们组件拆分的粒度  
CCP:  
    为了相同目的而同时修改的类, 应该放在同一个组件中  
    CCP 原则是 SRP 原则在组件层面的描述  
    该原则指导我们组件拆分的粒度  
CRP:  
    不要强迫一个组件依赖它不需要的东西  
    CRP 原则是 ISP 原则在组件层面的描述  
    该原则指导我们组件拆分的粒度  

    REP、CCP、CRP 三个原则之间存在彼此竞争的关系,  
    REP 和 CCP 是黏合性原则, 它们会让组件变得更大,  
    而 CRP 原则是排除性原则, 它会让组件变小。  
    遵守 REP、CCP 而忽略 CRP, 就会依赖了太多没有用到的组件和类, 而这些组件或类的变动会导致你自己的组件进行太多不必要的发布；  
    遵守 REP、CRP 而忽略 CCP, 因为组件拆分的太细了, 一个需求变更可能要改n个组件, 带来的成本也是巨大的。  

组件依赖三原则:  
    无依赖环原则:  
        健康的依赖应该是个有向无环图  
    稳定依赖原则:  
        依赖必须要指向更稳定的方向  
    稳定抽象原则:  
        一个组件的抽象化程度应该与其稳定性保持一致  
```

PS: 原则来源[阿里技术](https://mp.weixin.qq.com/s/Kd1T40KZWvdThKC3IN6n-Q)

面向过程设计
--

> 流程的处理, 遇到一个问题解决一个问题

面向切片(切面)设计
--

> 这种在运行时, 动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。  
> 个人总结: 基层是对象, 对象遇到一个动作, 附加一个动作, 类似Yii2的behaviors, Events, Laravel的hook  
> 也即是监听者模式, 代理模式等的实现

PS: 第一句来源[知乎](https://www.zhihu.com/question/24863332)
